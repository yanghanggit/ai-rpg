# 战斗系统架构与数据流

## 核心设计原则

### 职责分离，数据单向流动

- 状态效果仅在DrawCards阶段参与计算，合入卡牌数值后"消失"
- Arbitration只知道"当前HP + 卡牌最终数值"，不重复显示状态效果
- 属性知晓范围严格限定，避免信息冗余

## 三大核心系统

### 1. CombatInitializationSystem（战斗初始化）

**职责**：生成战斗开始时的初始状态效果

**输入**：角色信息、场景环境、阵营关系  
**输出**：每个角色的初始状态效果列表（如"主场威压"、"刻骨仇恨"）  
**知晓范围**：完整角色属性和场景信息

### 2. DrawCardsActionSystem（卡牌生成）

**职责**：将技能转化为行动卡牌，状态效果合入数值

**核心机制**：

```text
基础属性 × 状态效果修正 → 卡牌数值
```

**输入**：

- 角色基础属性（HP/攻击/防御）
- 状态效果列表（当前所有效果）
- 技能信息（由外部决策提供）
- 目标列表（由系统指定）

**输出**：Card对象

- name（Agent创造性生成）
- action（第一人称行动叙事，由 Agent 生成）
- stats: CharacterStats（hp/attack/defense，已包含状态修正）
- targets（系统指定，Agent不生成）
- status_effects（传入的状态效果，标记为“已使用”）
- affixes（规则列表，包含战术/代价/装备词条）
- affixes（规则列表：["战术:…", "代价:…", 装备词条]）
- status_effects（传入的状态效果，标记为"已使用"）

**LLM输出格式**：

```json
- **三段式输出**：action（叙事）+ mechanism（战术规则）+ cost（代价，可选）
- **Prompt约束强化**：明确要求无代价时输出空字符串“”，禁止输出“无”等文字
- **统一规则表达**：mechanism+cost 通过 @property affixes 转为统一的规则列表
  "name": "行动名",
  "action": "第一人称动作与战术意图",
  "mechanism": "战斗规则声明",
  "cost": "",
  "final_attack": 0,
  "final_defense": 0
}
```

**数据转换**：

- mechanism + cost → affixes @property → ["战术:…", "代价:…"]
- 装备词条追加到 affixes 列表
- cost 为空字符串时自动过滤，不显示"代价：无"

**关键优化**：

- 示例数值设为0，消除锚定效应
- 提示词强调"必须基于你的攻击属性"
- 压缩说明文字，减少Token消耗
- **Prompt约束**：明确要求cost为空时输出""，禁止"无""None"等文字

**知晓范围**：完整基础属性 + 状态效果 → 唯一负责"数值泛化"的地方

### 3. ArbitrationActionSystem（战斗仲裁）

**职责**：基于卡牌数值执行战斗计算，处理环境互动

**核心机制**：

```text
卡牌数值（最终） + 环境互动 → 战斗结果
```

**输入**：

- 行动顺序（先手优势）
- 角色当前生命值（HP:X/Y）
- 卡牌完整信息（名称、描述、目标、属性）

**提示词格式**：

```text
### N. 卡牌：卡牌名

- **出牌者**：角色名 | HP:X/Y | 攻击:A | 防御:D
- **目标**：目标角色
- **行动**：第一人称叙事描述
- **规则**：
  - 战术：…
  - 代价：…
  - 装备词条：…
```

**规则统一化**：

- 所有战斗规则统一在 **规则** 列表中展示
- 不再分离【机制】【代价】概念，降低LLM认知负担
- 空列表时显示"无"

**输出**：

- combat_log（紧凑格式战斗日志）
- final_hp（所有角色最终HP）
- narrative（感官描写的战斗演出）

**知晓范围**：只知道当前HP + 卡牌最终数值，不知道基础属性和状态效果

**关键优化**：

- Token压缩60%（紧凑格式 + 精简规则）
- 移除状态效果冗余显示
- 简化战斗机制（单一伤害类型，移除法术/持续效果）

## 辅助系统

### StatusEffectsEvaluationSystem（状态效果评估）

**职责**：战斗后根据结果评估新增状态效果
**输入**：战斗广播（演出 + 数据日志）+ 现有状态效果列表  
**输出**：新增状态效果（避免重复）  
**知晓范围**：战斗结果，不参与数值计算

### PlayCardsActionSystem（出牌通知）

**职责**：向角色发送出牌通知

**输出格式**：

```text
# 使用卡牌: [卡牌名]

目标: [目标]

【行动】
[第一人称叙事]

【规则】
- 战术：…
- 代价：…
- 装备词条：…
```

## 完整数据流

```text
[战斗初始化]
  └─ 生成初始状态效果

[回合开始]
  └─ DrawCards：基础属性 + 状态效果 → Card(stats, status_effects)

[出牌阶段]
  └─ PlayCards：通知角色出牌（含卡牌属性）

[仲裁阶段]
  └─ Arbitration：只显示"角色生命 + 卡牌属性" → 执行战斗

[结算阶段]
  ├─ 更新HP（基于final_hp）
  ├─ 清除状态效果（精确删除Card.status_effects）
  ├─ 通知状态消耗（发送被移除的效果列表）
  ├─ 处理死亡（HP≤0 → DeathComponent）
  └─ 评估新状态（基于战斗结果）
```

## 状态效果生命周期

```text
生成 → 传入DrawCards → 合入卡牌数值 → 打出卡牌 → 精确清除 → 通知Agent
```

关键特性：

- **一次性消耗**：状态效果用于生成卡牌后立即清除
- **精确匹配**：按名称删除Card.status_effects中的效果，不是clear()
- **通知机制**：向Agent发送被移除的状态列表
- **全局固有特性**：kick_off_message可定义固有特性（如被动能力、体质特征），作为全局约束贯穿Agent的context。固有特性仍遵循一次性消耗，但需在指定的关键节点（如战斗初始化、状态效果评估）持续重新生成，确保效果衔接

## 系统执行顺序

1. CombatInitializationSystem（战斗开始时一次）
2. DrawCardsActionSystem（每回合，生成卡牌）
3. PlayCardsActionSystem（每回合，出牌通知）
4. ArbitrationActionSystem（每回合，战斗仲裁）
5. StatusEffectsEvaluationSystem（每回合，评估新状态）
6. ActionCleanupSystem（每回合，清理组件）

## 最佳实践

1. **属性知晓范围**：每个系统只知道它需要知道的
2. **数据单向流动**：避免循环依赖和信息回流
3. **状态效果一次性**：用后即删，不保留到下回合
4. **提示词压缩**：消除冗余，保留关键信息
5. **示例值谨慎**：避免锚定效应，用0或明显不合理的值
