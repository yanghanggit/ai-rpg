# 消息可靠性传递方案设计

## 📋 文档信息

- **创建日期**: 2025年10月18日
- **作者**: AI-RPG开发团队
- **版本**: v1.0
- **适用项目**: 狼人杀游戏后端服务

---

## 🎯 问题背景

### 当前架构

```python
# 状态A
await web_game.werewolf_game_kickoff_pipeline.process()
# 状态B
return WerewolfGamePlayResponse(
    client_messages=web_game.player_session.session_messages
)
```

### 核心问题

**场景**: POST请求执行完毕,游戏状态已从A→B,但客户端因网络故障等原因未收到响应。

**风险**:

1. ❌ 服务器状态已改变,客户端状态未同步
2. ❌ 客户端重试可能导致重复执行
3. ❌ 无法追溯丢失的游戏事件
4. ❌ 玩家体验受损(看不到游戏进展)

---

## 🏗️ 解决方案总览

### 方案对比矩阵

| 方案 | 可靠性 | 实现复杂度 | 实时性 | 存储开销 | 推荐场景 |
|------|--------|-----------|--------|---------|----------|
| 事件溯源+增量拉取 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | 中等 | **回合制游戏(推荐)** |
| 幂等性设计+请求去重 | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ | 低 | 短期重试保护 |
| 两阶段提交 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | 高 | 金融级应用 |
| WebSocket实时推送 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 低 | 实时对战游戏 |

---

## 📐 方案一: 事件溯源 + 增量拉取 (推荐)

### 方案一核心思想

- 所有游戏事件都带**唯一递增序列号**
- 服务器**持久化**所有事件历史
- 客户端可随时请求**增量事件**补偿

### 事件溯源架构设计

```python
# 1. 扩展PlayerSession支持事件序列
class PlayerSession:
    def __init__(self, name: str, actor: str) -> None:
        self._name: Final[str] = name
        self._actor: Final[str] = actor
        self._session_messages: List[SessionMessage] = []
        
        # 新增: 事件溯源支持
        self._event_sequence: int = 0  # 全局事件序列号
        self._event_history: List[SessionMessage] = []  # 历史事件缓存
        self._max_history_size: int = 1000  # 最多保留1000个事件

    def add_agent_event_message(self, agent_event: AgentEvent) -> None:
        # 生成递增序列号
        self._event_sequence += 1
        
        # 创建带序列号的消息
        message = SessionMessage(
            sequence_id=self._event_sequence,  # 关键: 唯一序列号
            timestamp=time.time(),
            message_type=MessageType.AGENT_EVENT,
            data=agent_event.model_dump()
        )
        
        # 添加到当前会话消息
        self._session_messages.append(message)
        
        # 添加到历史记录
        self._event_history.append(message)
        
        # 限制历史记录大小
        if len(self._event_history) > self._max_history_size:
            self._event_history = self._event_history[-self._max_history_size:]
    
    def get_events_since(self, last_sequence_id: int) -> List[SessionMessage]:
        """获取指定序列号之后的所有事件"""
        return [
            msg for msg in self._event_history 
            if msg.sequence_id > last_sequence_id
        ]
    
    def get_current_sequence_id(self) -> int:
        """获取当前最新的序列号"""
        return self._event_sequence
```

### API设计

```python
# 新增: 增量事件查询API
@werewolf_game_api_router.get(
    path="/api/werewolf/events/v1/{user_name}/incremental",
    response_model=IncrementalEventsResponse
)
async def get_incremental_events(
    game_server: GameServerInstance,
    user_name: str,
    last_event_id: int = Query(default=0, description="客户端最后收到的事件ID"),
) -> IncrementalEventsResponse:
    """
    增量事件拉取接口
    
    用途:
    - 客户端网络恢复后补拉丢失的事件
    - 断线重连后同步游戏状态
    - 调试时查看事件历史
    """
    logger.info(
        f"Fetching incremental events for {user_name} since event_id={last_event_id}"
    )
    
    try:
        # 验证房间和游戏
        if not game_server.has_room(user_name):
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="房间不存在"
            )
        
        current_room = game_server.get_room(user_name)
        assert current_room is not None
        
        if current_room._sdg_game is None:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="游戏不存在"
            )
        
        # 获取增量事件
        web_game = current_room._sdg_game
        incremental_events = web_game.player_session.get_events_since(last_event_id)
        current_sequence = web_game.player_session.get_current_sequence_id()
        
        logger.info(
            f"Returning {len(incremental_events)} events, "
            f"current_sequence={current_sequence}"
        )
        
        return IncrementalEventsResponse(
            events=incremental_events,
            current_sequence_id=current_sequence,
            has_more=False  # 当前实现返回所有增量事件
        )
        
    except Exception as e:
        logger.error(f"Error fetching incremental events: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"获取增量事件失败: {str(e)}"
        )
```

### 客户端使用示例

```typescript
// 客户端状态管理
class GameClient {
    private lastEventId: number = 0;
    
    async playGame(command: string) {
        try {
            const response = await fetch('/api/werewolf/gameplay/v1/', {
                method: 'POST',
                body: JSON.stringify({ user_input: command })
            });
            
            if (response.ok) {
                const data = await response.json();
                this.processEvents(data.client_messages);
                
                // 更新最后收到的事件ID
                if (data.client_messages.length > 0) {
                    const lastMsg = data.client_messages[data.client_messages.length - 1];
                    this.lastEventId = lastMsg.sequence_id;
                }
            }
        } catch (error) {
            console.error('Request failed:', error);
            // 网络失败后,尝试补拉事件
            await this.pullMissingEvents();
        }
    }
    
    async pullMissingEvents() {
        const response = await fetch(
            `/api/werewolf/events/v1/user123/incremental?last_event_id=${this.lastEventId}`
        );
        const data = await response.json();
        
        if (data.events.length > 0) {
            console.log(`Recovered ${data.events.length} missing events`);
            this.processEvents(data.events);
            this.lastEventId = data.current_sequence_id;
        }
    }
    
    // 定期轮询补偿机制(可选)
    startHeartbeat() {
        setInterval(() => this.pullMissingEvents(), 5000); // 每5秒检查一次
    }
}
```

### 方案一优势

✅ **可靠性高**: 事件永不丢失,可随时补拉  
✅ **支持回放**: 完整事件历史可用于调试和回放  
✅ **断线重连**: 客户端重连后能快速同步状态  
✅ **可观测性**: 便于监控和日志分析

### 方案一劣势

⚠️ **存储开销**: 需要保存事件历史(可设置过期策略)  
⚠️ **实现复杂度**: 需要修改多个组件

---

## 🔒 方案二: 幂等性设计 + 请求去重

### 方案二核心思想

- 客户端为每个请求生成**唯一请求ID**
- 服务器检测并拒绝**重复请求**
- 返回缓存的响应结果

### 实现代码

```python
import uuid
from datetime import datetime, timedelta
from typing import Dict, Optional

# 请求缓存管理器
class RequestCache:
    def __init__(self, expire_seconds: int = 3600):
        self._cache: Dict[str, tuple[WerewolfGamePlayResponse, datetime]] = {}
        self._expire_seconds = expire_seconds
    
    def get(self, request_id: str) -> Optional[WerewolfGamePlayResponse]:
        """获取缓存的响应"""
        if request_id in self._cache:
            response, timestamp = self._cache[request_id]
            # 检查是否过期
            if datetime.now() - timestamp < timedelta(seconds=self._expire_seconds):
                return response
            else:
                del self._cache[request_id]
        return None
    
    def set(self, request_id: str, response: WerewolfGamePlayResponse) -> None:
        """缓存响应"""
        self._cache[request_id] = (response, datetime.now())
    
    def cleanup_expired(self) -> None:
        """清理过期缓存"""
        now = datetime.now()
        expired_keys = [
            k for k, (_, ts) in self._cache.items()
            if now - ts >= timedelta(seconds=self._expire_seconds)
        ]
        for key in expired_keys:
            del self._cache[key]

# 在GameServerInstance中添加
class GameServerInstance:
    def __init__(self):
        self._rooms: Dict[str, Room] = {}
        self._request_cache = RequestCache(expire_seconds=3600)  # 1小时过期

# 修改后的API
@werewolf_game_api_router.post(
    path="/api/werewolf/gameplay/v1/", 
    response_model=WerewolfGamePlayResponse
)
async def play_werewolf_game(
    payload: WerewolfGamePlayRequest,
    game_server: GameServerInstance,
) -> WerewolfGamePlayResponse:
    logger.info(f"Playing werewolf game: {payload.model_dump_json()}")
    
    # 检查是否重复请求
    if payload.request_id:
        cached_response = game_server._request_cache.get(payload.request_id)
        if cached_response:
            logger.warning(
                f"Duplicate request detected: {payload.request_id}, "
                f"returning cached response"
            )
            return cached_response
    
    try:
        # ... 原有的游戏逻辑 ...
        
        # 示例: /kickoff命令
        if user_input == "/k" or user_input == "/kickoff":
            if web_game._turn_counter == 0:
                web_game.player_session.clear_messages()
                await web_game.werewolf_game_kickoff_pipeline.process()
                
                response = WerewolfGamePlayResponse(
                    client_messages=web_game.player_session.session_messages
                )
                
                # 缓存响应
                if payload.request_id:
                    game_server._request_cache.set(payload.request_id, response)
                
                return response
        
        # ... 其他命令处理 ...
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"gameplay/v1: {payload.user_name} failed, error: {str(e)}",
        )
```

### 数据模型修改

```python
# 在WerewolfGamePlayRequest中添加request_id字段
class WerewolfGamePlayRequest(BaseModel):
    user_name: str
    game_name: str
    data: Dict[str, Any]
    request_id: Optional[str] = None  # 新增: 客户端生成的唯一请求ID
```

### 方案一客户端示例

```typescript
class GameClient {
    async playGame(command: string) {
        const requestId = crypto.randomUUID(); // 生成UUID
        
        try {
            const response = await fetch('/api/werewolf/gameplay/v1/', {
                method: 'POST',
                body: JSON.stringify({
                    user_name: 'player1',
                    game_name: 'werewolf',
                    data: { user_input: command },
                    request_id: requestId  // 关键: 发送请求ID
                })
            });
            
            // 处理响应...
        } catch (error) {
            // 重试时使用相同的requestId
            await this.retryRequest(requestId, command);
        }
    }
    
    async retryRequest(requestId: string, command: string) {
        // 使用相同的request_id重试
        const response = await fetch('/api/werewolf/gameplay/v1/', {
            method: 'POST',
            body: JSON.stringify({
                user_name: 'player1',
                game_name: 'werewolf',
                data: { user_input: command },
                request_id: requestId  // 相同的ID,服务器会返回缓存结果
            })
        });
    }
}
```

### 方案二优势

✅ **实现简单**: 代码改动小,容易理解  
✅ **性能好**: 内存缓存,响应快速  
✅ **防重复执行**: 天然支持幂等性

### 方案二劣势

⚠️ **时效性限制**: 缓存过期后无法补救  
⚠️ **内存占用**: 需要缓存响应数据  
⚠️ **不支持长期恢复**: 只适合短期重试

---

## 🔄 方案三: 两阶段提交 (2PC)

### 方案三核心思想

- **阶段1(Prepare)**: 预处理,不改变最终状态
- **阶段2(Commit)**: 客户端确认后才正式提交

### 两阶段提交架构流程

```text
客户端                    服务器
  |                         |
  |--- POST /prepare ------>| 
  |                         | 执行逻辑,生成事件
  |                         | 但标记为"待确认"
  |<--- transaction_id -----| 
  |                         |
  |                         | [等待确认...]
  |                         |
  |--- POST /commit ------->| 
  |   (transaction_id)      | 正式提交事件
  |<--- success ------------|
```

### 实现示例

```python
from enum import Enum
from dataclasses import dataclass
from typing import Dict

class TransactionState(Enum):
    PREPARED = "prepared"
    COMMITTED = "committed"
    ROLLED_BACK = "rolled_back"
    EXPIRED = "expired"

@dataclass
class PendingTransaction:
    transaction_id: str
    user_name: str
    events: List[SessionMessage]
    state: TransactionState
    created_at: datetime
    expire_at: datetime

class TransactionManager:
    def __init__(self, timeout_seconds: int = 60):
        self._transactions: Dict[str, PendingTransaction] = {}
        self._timeout_seconds = timeout_seconds
    
    def create_transaction(
        self, 
        user_name: str, 
        events: List[SessionMessage]
    ) -> str:
        """创建待确认事务"""
        transaction_id = str(uuid.uuid4())
        now = datetime.now()
        
        self._transactions[transaction_id] = PendingTransaction(
            transaction_id=transaction_id,
            user_name=user_name,
            events=events,
            state=TransactionState.PREPARED,
            created_at=now,
            expire_at=now + timedelta(seconds=self._timeout_seconds)
        )
        
        return transaction_id
    
    def commit_transaction(self, transaction_id: str) -> List[SessionMessage]:
        """提交事务"""
        if transaction_id not in self._transactions:
            raise ValueError(f"Transaction {transaction_id} not found")
        
        txn = self._transactions[transaction_id]
        
        if datetime.now() > txn.expire_at:
            txn.state = TransactionState.EXPIRED
            raise ValueError(f"Transaction {transaction_id} expired")
        
        txn.state = TransactionState.COMMITTED
        return txn.events
    
    def rollback_transaction(self, transaction_id: str) -> None:
        """回滚事务"""
        if transaction_id in self._transactions:
            self._transactions[transaction_id].state = TransactionState.ROLLED_BACK

# API实现
@werewolf_game_api_router.post("/api/werewolf/gameplay/prepare/v1")
async def prepare_gameplay(
    payload: WerewolfGamePlayRequest,
    game_server: GameServerInstance,
) -> PrepareResponse:
    """第一阶段: 准备游戏操作"""
    
    # 执行游戏逻辑,但不持久化
    web_game = current_room._sdg_game
    web_game.player_session.clear_messages()
    
    await web_game.werewolf_game_kickoff_pipeline.process()
    events = web_game.player_session.session_messages.copy()
    
    # 创建待确认事务
    transaction_id = game_server._transaction_manager.create_transaction(
        user_name=payload.user_name,
        events=events
    )
    
    return PrepareResponse(
        transaction_id=transaction_id,
        preview_events=events  # 预览事件
    )

@werewolf_game_api_router.post("/api/werewolf/gameplay/commit/v1")
async def commit_gameplay(
    transaction_id: str,
    game_server: GameServerInstance,
) -> WerewolfGamePlayResponse:
    """第二阶段: 确认提交"""
    
    try:
        events = game_server._transaction_manager.commit_transaction(transaction_id)
        return WerewolfGamePlayResponse(client_messages=events)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
```

### 方案三优势

✅ **最高可靠性**: 客户端确认后才真正提交  
✅ **支持回滚**: 失败可以撤销  
✅ **金融级**: 适合对一致性要求极高的场景

### 方案三劣势

⚠️ **复杂度极高**: 需要大量额外代码  
⚠️ **性能开销**: 每次操作需要两次往返  
⚠️ **状态管理**: 需要处理超时、过期等复杂情况

---

## 🌐 方案四: WebSocket实时推送

### 方案四核心思想

- 使用**长连接**代替HTTP短连接
- 服务器主动推送事件到客户端
- 天然支持实时性和可靠性

### 架构设计

```python
from fastapi import WebSocket, WebSocketDisconnect
from typing import Dict, Set

class ConnectionManager:
    def __init__(self):
        self._active_connections: Dict[str, WebSocket] = {}
    
    async def connect(self, user_name: str, websocket: WebSocket):
        await websocket.accept()
        self._active_connections[user_name] = websocket
        logger.info(f"User {user_name} connected via WebSocket")
    
    def disconnect(self, user_name: str):
        if user_name in self._active_connections:
            del self._active_connections[user_name]
            logger.info(f"User {user_name} disconnected")
    
    async def send_personal_message(self, user_name: str, message: dict):
        if user_name in self._active_connections:
            await self._active_connections[user_name].send_json(message)
    
    async def broadcast(self, message: dict):
        for connection in self._active_connections.values():
            await connection.send_json(message)

manager = ConnectionManager()

@werewolf_game_api_router.websocket("/ws/werewolf/{user_name}")
async def websocket_endpoint(
    websocket: WebSocket, 
    user_name: str,
    game_server: GameServerInstance
):
    await manager.connect(user_name, websocket)
    
    try:
        while True:
            # 接收客户端命令
            data = await websocket.receive_json()
            command = data.get("user_input", "")
            
            # 执行游戏逻辑
            room = game_server.get_room(user_name)
            web_game = room._sdg_game
            
            web_game.player_session.clear_messages()
            await web_game.werewolf_game_kickoff_pipeline.process()
            
            # 实时推送事件
            for event in web_game.player_session.session_messages:
                await manager.send_personal_message(
                    user_name,
                    {
                        "type": "game_event",
                        "data": event.model_dump()
                    }
                )
    
    except WebSocketDisconnect:
        manager.disconnect(user_name)
        logger.info(f"User {user_name} disconnected")
```

### 客户端示例

```typescript
class GameWebSocketClient {
    private ws: WebSocket;
    private reconnectAttempts = 0;
    private maxReconnectAttempts = 5;
    
    connect(userName: string) {
        this.ws = new WebSocket(`ws://server/ws/werewolf/${userName}`);
        
        this.ws.onopen = () => {
            console.log('WebSocket connected');
            this.reconnectAttempts = 0;
        };
        
        this.ws.onmessage = (event) => {
            const message = JSON.parse(event.data);
            if (message.type === 'game_event') {
                this.handleGameEvent(message.data);
            }
        };
        
        this.ws.onclose = () => {
            console.log('WebSocket disconnected, attempting reconnect...');
            this.reconnect(userName);
        };
        
        this.ws.onerror = (error) => {
            console.error('WebSocket error:', error);
        };
    }
    
    reconnect(userName: string) {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            setTimeout(() => {
                this.reconnectAttempts++;
                this.connect(userName);
            }, 1000 * Math.pow(2, this.reconnectAttempts)); // 指数退避
        }
    }
    
    sendCommand(command: string) {
        this.ws.send(JSON.stringify({
            user_input: command
        }));
    }
}
```

### 方案四优势

✅ **实时性最佳**: 毫秒级延迟  
✅ **自动重连**: 断线后自动恢复  
✅ **服务器推送**: 主动通知客户端  
✅ **适合多人游戏**: 支持广播和群发

### 方案四劣势

⚠️ **连接管理复杂**: 需要处理心跳、重连等  
⚠️ **服务器压力**: 长连接占用资源  
⚠️ **兼容性**: 某些网络环境可能不支持

---

## 🎯 针对狼人杀游戏的推荐实施方案

### 分阶段实施路线图

#### 🚀 第一阶段: 快速防护 (1-2天)

##### 实施方案2: 幂等性 + 请求去重

**任务清单**:

- [ ] 在`WerewolfGamePlayRequest`中添加`request_id`字段
- [ ] 实现`RequestCache`类
- [ ] 在`GameServerInstance`中集成缓存
- [ ] 修改所有POST接口支持请求去重
- [ ] 客户端生成UUID作为请求ID

**预期效果**:

- 防止短期内的重复执行
- 客户端重试能获得一致结果
- 实现成本低,风险小

---

#### 📈 第二阶段: 增强可靠性 (1周)

##### 实施方案1: 事件溯源 + 增量拉取

**任务清单**:

- [ ] 扩展`PlayerSession`支持事件序列号
- [ ] 实现`get_events_since()`方法
- [ ] 新增`/api/werewolf/events/v1/{user_name}/incremental` API
- [ ] 修改`SessionMessage`模型添加序列号和时间戳
- [ ] 客户端实现增量拉取逻辑
- [ ] 添加定时轮询机制(可选)

**预期效果**:

- 支持断线重连后状态恢复
- 完整的事件历史可追溯
- 提升玩家体验

---

#### 🔮 第三阶段: 长期优化 (可选)

##### 实施方案4: WebSocket实时推送**

**任务清单**:

- [ ] 评估WebSocket必要性(取决于实时性需求)
- [ ] 实现`ConnectionManager`
- [ ] 添加WebSocket端点
- [ ] 客户端改造为WebSocket通信
- [ ] 实现心跳和重连机制

**预期效果**:

- 实现真正的实时游戏体验
- 支持服务器主动推送(如其他玩家行动通知)

---

## 📊 实施建议与最佳实践

### 选择决策树

```text
是否需要金融级可靠性?
├─ 是 → 方案3: 两阶段提交
└─ 否 → 是否需要毫秒级实时性?
    ├─ 是 → 方案4: WebSocket
    └─ 否 → 回合制游戏?
        ├─ 是 → 方案1(事件溯源) + 方案2(幂等性) ✅ 推荐
        └─ 否 → 仅方案2(幂等性)
```

### 通用最佳实践

1. **日志记录**

   ```python
   logger.info(f"[Request:{request_id}] Processing command: {command}")
   logger.info(f"[Request:{request_id}] Generated {len(events)} events")
   ```

2. **监控指标**

   - 请求去重命中率
   - 增量拉取请求频率
   - 事件序列号跳变检测

3. **测试策略**

   - 网络中断模拟测试
   - 并发请求压力测试
   - 客户端重试场景测试

4. **容错设计**

   ```python
   # 设置合理的超时时间
   REQUEST_TIMEOUT = 30  # 秒
   
   # 限制重试次数
   MAX_RETRY_ATTEMPTS = 3
   
   # 指数退避策略
   retry_delay = min(2 ** attempt, 60)  # 最多60秒
   ```

---

## 🔍 附录: 相关技术参考

### 业界案例

- **Discord**: 使用WebSocket + 事件序列号
- **Slack**: 使用请求ID去重 + RTM API
- **王者荣耀**: 帧同步 + 状态确认

### 技术文档

- [FastAPI WebSocket文档](https://fastapi.tiangolo.com/advanced/websockets/)
- [幂等性设计模式](https://en.wikipedia.org/wiki/Idempotence)
- [事件溯源(Event Sourcing)](https://martinfowler.com/eaaDev/EventSourcing.html)

### 开源工具推荐

- **Redis**: 用于分布式请求缓存
- **PostgreSQL**: 持久化事件历史
- **Socket.IO**: 成熟的WebSocket库

---

## 📝 版本历史

| 版本 | 日期 | 更新内容 |
|------|------|----------|
| v1.0 | 2025-10-18 | 初始版本,包含4种解决方案 |

---

## 👥 贡献者

- AI-RPG开发团队
- 技术架构组

---

**文档状态**: ✅ 已审核  
**下次审核日期**: 2025-11-18
