# 消息可靠性传递方案设计

---

## 🎯 问题背景

### 核心问题

**场景**: POST请求执行完毕,游戏状态已从A→B,但客户端因网络故障等原因未收到响应。

**风险**:

1. ❌ 服务器状态已改变,客户端状态未同步
2. ❌ 客户端重试可能导致重复执行
3. ❌ 无法追溯丢失的游戏事件
4. ❌ 玩家体验受损(看不到游戏进展)

---

## 🏗️ 解决方案总览

### 方案对比矩阵

| 方案 | 可靠性 | 实现复杂度 | 实时性 | 存储开销 | 推荐场景 |
| ------ | -------- | ----------- | -------- | --------- | ---------- |
| 事件溯源+增量拉取 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | 中等 | **回合制游戏(推荐)** |
| 幂等性设计+请求去重 | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ | 低 | 短期重试保护 |
| 两阶段提交 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | 高 | 金融级应用 |
| WebSocket实时推送 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 低 | 实时对战游戏 |

---

## 📐 方案一: 事件溯源 + 增量拉取 (推荐)

### 方案一核心思想

- 所有游戏事件都带**唯一递增序列号**
- 服务器**持久化**所有事件历史
- 客户端可随时请求**增量事件**补偿

### 方案一实现要点

1. **扩展PlayerSession支持事件序列**
   - 添加全局事件序列号
   - 维护事件历史缓存
   - 限制历史记录大小

2. **增量事件API设计**
   - 支持按序列号查询增量事件
   - 返回当前最新序列号
   - 处理房间/游戏不存在的异常情况

3. **客户端策略**
   - 记录最后收到的事件ID
   - 网络失败后主动补拉事件
   - 可选:定期轮询补偿机制

### 方案一优势

✅ **可靠性高**: 事件永不丢失,可随时补拉  
✅ **支持回放**: 完整事件历史可用于调试和回放  
✅ **断线重连**: 客户端重连后能快速同步状态  
✅ **可观测性**: 便于监控和日志分析

### 方案一劣势

⚠️ **存储开销**: 需要保存事件历史(可设置过期策略)  
⚠️ **实现复杂度**: 需要修改多个组件

---

## 🔒 方案二: 幂等性设计 + 请求去重

### 方案二核心思想

- 客户端为每个请求生成**唯一请求ID**
- 服务器检测并拒绝**重复请求**
- 返回缓存的响应结果

### 方案二实现要点

1. **请求缓存管理器**
   - 存储请求ID和对应响应
   - 支持过期时间配置
   - 定期清理过期缓存

2. **数据模型修改**
   - 在请求中添加request_id字段
   - 支持可选的请求ID参数

3. **API幂等性处理**
   - 检查是否为重复请求
   - 返回缓存响应避免重复执行
   - 为新请求缓存响应结果

4. **客户端实现**
   - 生成UUID作为请求ID
   - 重试时使用相同的requestId
   - 保证幂等性

### 方案二优势

✅ **实现简单**: 代码改动小,容易理解  
✅ **性能好**: 内存缓存,响应快速  
✅ **防重复执行**: 天然支持幂等性

### 方案二劣势

⚠️ **时效性限制**: 缓存过期后无法补救  
⚠️ **内存占用**: 需要缓存响应数据  
⚠️ **不支持长期恢复**: 只适合短期重试

---

## 🔄 方案三: 两阶段提交 (2PC)

### 方案三核心思想

- **阶段1(Prepare)**: 预处理,不改变最终状态
- **阶段2(Commit)**: 客户端确认后才正式提交

### 方案三实现要点

1. **事务状态管理**
   - PREPARED: 已准备,待确认
   - COMMITTED: 已提交
   - ROLLED_BACK: 已回滚
   - EXPIRED: 已过期

2. **两阶段提交架构流程**
   - 客户端发送prepare请求
   - 服务器执行逻辑但标记为待确认
   - 返回transaction_id给客户端
   - 客户端发送commit确认
   - 服务器正式提交事件

3. **超时和过期处理**
   - 设置事务超时时间
   - 定期清理过期事务
   - 支持事务回滚

### 方案三优势

✅ **最高可靠性**: 客户端确认后才真正提交  
✅ **支持回滚**: 失败可以撤销  
✅ **金融级**: 适合对一致性要求极高的场景

### 方案三劣势

⚠️ **复杂度极高**: 需要大量额外代码  
⚠️ **性能开销**: 每次操作需要两次往返  
⚠️ **状态管理**: 需要处理超时、过期等复杂情况

---

## 🌐 方案四: WebSocket实时推送

### 方案四核心思想

- 使用**长连接**代替HTTP短连接
- 服务器主动推送事件到客户端
- 天然支持实时性和可靠性

### 方案四实现要点

1. **连接管理器**
   - 维护活动连接字典
   - 支持连接/断开操作
   - 实现单播和广播功能

2. **WebSocket端点实现**
   - 接收客户端命令
   - 执行游戏逻辑
   - 实时推送事件

3. **客户端实现**
   - 建立WebSocket连接
   - 实现自动重连机制
   - 指数退避重连策略
   - 处理连接错误和关闭

### 方案四优势

✅ **实时性最佳**: 毫秒级延迟  
✅ **自动重连**: 断线后自动恢复  
✅ **服务器推送**: 主动通知客户端  
✅ **适合多人游戏**: 支持广播和群发

### 方案四劣势

⚠️ **连接管理复杂**: 需要处理心跳、重连等  
⚠️ **服务器压力**: 长连接占用资源  
⚠️ **兼容性**: 某些网络环境可能不支持
