"""
Áªü‰∏Ä MCP ÂÆ¢Êà∑Á´ØÂÆûÁé∞

Âü∫‰∫éÂÆòÊñπ MCP Python SDK ÁöÑÊ†áÂáÜÂÆ¢Êà∑Á´ØÂÆûÁé∞ÔºåÁî®‰∫é‰∏éÊ†áÂáÜ MCP ÊúçÂä°Âô®ÈÄö‰ø°„ÄÇ
ÊîØÊåÅÂ§öÁßç‰º†ËæìÂçèËÆÆÔºöstdio„ÄÅstreamable-http„ÄÇ
"""

import os

# import asyncio
import httpx
from typing import Any, Dict, List, Optional

from loguru import logger
from pydantic import BaseModel

# MCP SDK ÂØºÂÖ•
from mcp.client.session import ClientSession
from mcp.client.stdio import StdioServerParameters, stdio_client


class McpToolInfo(BaseModel):
    """MCP Â∑•ÂÖ∑‰ø°ÊÅØ"""

    name: str
    description: str
    input_schema: Dict[str, Any]


class McpToolResult(BaseModel):
    """MCP Â∑•ÂÖ∑ÊâßË°åÁªìÊûú"""

    success: bool
    result: Any
    error: Optional[str] = None
    execution_time: float


class McpClient:
    """Áªü‰∏Ä MCP ÂÆ¢Êà∑Á´ØÂÆûÁé∞"""

    def __init__(
        self,
        server_url: Optional[str] = None,
        server_config: Optional[Dict[str, Any]] = None,
    ):
        """
        ÂàùÂßãÂåñ MCP ÂÆ¢Êà∑Á´Ø

        Args:
            server_url: ÊúçÂä°Âô® URLÔºà‰ºöËá™Âä®ËΩ¨Êç¢‰∏∫ÈÄÇÂΩìÁöÑÈÖçÁΩÆÔºâ
                - http://localhost:8765 -> streamable-http Ê®°Âºè
                - python script.py -> stdio Ê®°Âºè
            server_config: Áõ¥Êé•ÊúçÂä°Âô®ÈÖçÁΩÆÔºà‰ºòÂÖàÁ∫ßÊõ¥È´òÔºâ
                ÂØπ‰∫é stdio Ê®°Âºè: {"transport": "stdio", "command": "python", "args": ["server.py"]}
                ÂØπ‰∫é streamable-http Ê®°Âºè: {"transport": "streamable-http", "url": "http://localhost:8765"}
        """
        if server_config:
            # ‰ΩøÁî®Áõ¥Êé•ÈÖçÁΩÆ
            self.server_config = server_config
        elif server_url:
            # ‰ªé URL Ëá™Âä®Êé®Êñ≠ÈÖçÁΩÆ
            self.server_config = self._parse_server_url(server_url)
        else:
            # ÈªòËÆ§ÈÖçÁΩÆÔºàstdio Ê®°ÂºèÔºâ
            self.server_config = {
                "transport": "stdio",
                "command": "python",
                "args": ["scripts/run_sample_mcp_server.py", "--transport", "stdio"],
            }

        self.transport = self.server_config.get("transport", "stdio")
        self.session: Optional[ClientSession] = None
        self._tools_cache: Optional[List[McpToolInfo]] = None
        self._connection_context: Optional[Any] = None
        self._http_client: Optional[httpx.AsyncClient] = None

    def _parse_server_url(self, server_url: str) -> Dict[str, Any]:
        """Ëß£ÊûêÊúçÂä°Âô® URL Âπ∂ËøîÂõûÁõ∏Â∫îÁöÑÈÖçÁΩÆ"""
        if server_url.startswith("http"):
            # streamable-http Ê®°Âºè
            return {"transport": "streamable-http", "url": server_url.rstrip("/")}
        else:
            # ÂÅáËÆæÊòØÂëΩ‰ª§Ë°åÔºàstdio Ê®°ÂºèÔºâ
            return {
                "transport": "stdio",
                "command": server_url.split()[0],
                "args": server_url.split()[1:] if " " in server_url else [],
            }

    async def __aenter__(self) -> "McpClient":
        """ÂºÇÊ≠•‰∏ä‰∏ãÊñáÁÆ°ÁêÜÂô®ÂÖ•Âè£"""
        await self.connect()
        return self

    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
        """ÂºÇÊ≠•‰∏ä‰∏ãÊñáÁÆ°ÁêÜÂô®Âá∫Âè£"""
        await self.disconnect()

    async def connect(self) -> None:
        """ËøûÊé•Âà∞ MCP ÊúçÂä°Âô®"""
        try:
            if self.transport == "stdio":
                await self._connect_stdio()
            elif self.transport == "streamable-http":
                await self._connect_streamable_http()
            else:
                raise ValueError(f"‰∏çÊîØÊåÅÁöÑ‰º†ËæìÂçèËÆÆ: {self.transport}")

            logger.success(f"‚úÖ MCP ÂÆ¢Êà∑Á´ØÂ∑≤ËøûÊé• (transport: {self.transport})")

        except Exception as e:
            logger.error(f"‚ùå MCP ÂÆ¢Êà∑Á´ØËøûÊé•Â§±Ë¥•: {e}")
            raise

    async def _connect_stdio(self) -> None:
        """ËøûÊé• stdio Ê®°ÂºèÁöÑÊúçÂä°Âô®"""
        command = self.server_config.get("command", "python")
        args = self.server_config.get("args", [])
        env = self.server_config.get("env", {})

        server_params = StdioServerParameters(
            command=command, args=args, env={**os.environ, **env} if env else None
        )

        # ‰ΩøÁî® stdio_client ËøûÊé•
        self._connection_context = stdio_client(server_params)
        read_stream, write_stream = await self._connection_context.__aenter__()

        # ÂàõÂª∫‰ºöËØù
        self.session = ClientSession(read_stream, write_stream)
        await self.session.initialize()

    async def _connect_streamable_http(self) -> None:
        """ËøûÊé• streamable-http Ê®°ÂºèÁöÑÊúçÂä°Âô®"""
        base_url = self.server_config.get("url", "http://localhost:8765")

        # ÂàõÂª∫ HTTP ÂÆ¢Êà∑Á´Ø
        self._http_client = httpx.AsyncClient(base_url=base_url, timeout=30.0)

        # ÂØπ‰∫é streamable-httpÔºåÊàë‰ª¨ÈúÄË¶ÅÂÆûÁé∞Ê†áÂáÜÁöÑ HTTP/WebSocket ËøûÊé•
        # ËøôÈáåÊöÇÊó∂‰ΩøÁî®ÁÆÄÂåñÂÆûÁé∞ÔºåÂú®ÂÆûÈôÖÈÉ®ÁΩ≤‰∏≠ÈúÄË¶ÅÊ†πÊçÆ MCP ËßÑËåÉÂÆûÁé∞ÂÆåÊï¥ÁöÑ streamable-http ÂçèËÆÆ

        # ÂàõÂª∫Ê®°ÊãüÁöÑËØªÂÜôÊµÅÁî®‰∫éÂÖºÂÆπÁé∞ÊúâÁöÑ ClientSession API
        from asyncio import Queue

        # ÂàõÂª∫Ê∂àÊÅØÈòüÂàó
        read_queue: Queue[Any] = Queue()
        write_queue: Queue[Any] = Queue()

        # ÂàõÂª∫ÊµÅÈÄÇÈÖçÂô®
        class HttpStreamAdapter:
            def __init__(self, queue: Queue[Any], is_reader: bool = True):
                self._queue = queue
                self._is_reader = is_reader

            async def read_message(self) -> Any:
                if self._is_reader:
                    return await self._queue.get()
                raise RuntimeError("Cannot read from write stream")

            async def send_message(self, message: Any) -> None:
                if not self._is_reader:
                    await self._queue.put(message)
                else:
                    raise RuntimeError("Cannot write to read stream")

        read_stream = HttpStreamAdapter(read_queue, True)
        write_stream = HttpStreamAdapter(write_queue, False)

        # ÂàõÂª∫‰ºöËØù
        self.session = ClientSession(read_stream, write_stream)  # type: ignore
        await self.session.initialize()

    async def disconnect(self) -> None:
        """Êñ≠ÂºÄ‰∏é MCP ÊúçÂä°Âô®ÁöÑËøûÊé•"""
        try:
            if self.session:
                # Ê≥®ÊÑèÔºöClientSession Ê≤°Êúâ close ÊñπÊ≥ïÔºåËøûÊé•‰ºöÂú®‰∏ä‰∏ãÊñáÁÆ°ÁêÜÂô®ÈÄÄÂá∫Êó∂Ëá™Âä®ÂÖ≥Èó≠
                self.session = None

            if self._connection_context:
                await self._connection_context.__aexit__(None, None, None)
                self._connection_context = None

            if self._http_client:
                await self._http_client.aclose()
                self._http_client = None

            logger.info("üîå MCP ÂÆ¢Êà∑Á´ØÂ∑≤Êñ≠ÂºÄËøûÊé•")

        except Exception as e:
            logger.error(f"‚ùå Êñ≠ÂºÄ MCP ËøûÊé•Êó∂Âá∫Èîô: {e}")

    async def check_health(self) -> bool:
        """Ê£ÄÊü•ËøûÊé•ÂÅ•Â∫∑Áä∂ÊÄÅ"""
        try:
            if not self.session:
                return False

            # Â∞ùËØïÂàóÂá∫Â∑•ÂÖ∑Êù•Ê£ÄÊü•ËøûÊé•
            await self.get_available_tools()
            return True

        except Exception as e:
            logger.warning(f"‚ö†Ô∏è MCP ÂÅ•Â∫∑Ê£ÄÊü•Â§±Ë¥•: {e}")
            return False

    async def get_available_tools(
        self, force_refresh: bool = False
    ) -> List[McpToolInfo]:
        """Ëé∑ÂèñÂèØÁî®Â∑•ÂÖ∑ÂàóË°®"""
        if not force_refresh and self._tools_cache:
            return self._tools_cache

        try:
            if not self.session:
                raise RuntimeError("MCP ÂÆ¢Êà∑Á´ØÊú™ËøûÊé•")

            # Ë∞ÉÁî®Ê†áÂáÜ MCP ÂçèËÆÆ
            response = await self.session.list_tools()

            tools = []
            for tool in response.tools:
                tools.append(
                    McpToolInfo(
                        name=tool.name,
                        description=tool.description or "",
                        input_schema=tool.inputSchema or {},
                    )
                )

            self._tools_cache = tools
            logger.info(f"üìã Ëé∑ÂèñÂà∞ {len(tools)} ‰∏™ÂèØÁî®Â∑•ÂÖ∑")
            return tools

        except Exception as e:
            logger.error(f"‚ùå Ëé∑ÂèñÂ∑•ÂÖ∑ÂàóË°®Â§±Ë¥•: {e}")
            return []

    async def get_tool_info(self, tool_name: str) -> Optional[McpToolInfo]:
        """Ëé∑ÂèñÊåáÂÆöÂ∑•ÂÖ∑‰ø°ÊÅØ"""
        try:
            tools = await self.get_available_tools()
            for tool in tools:
                if tool.name == tool_name:
                    return tool
            return None

        except Exception as e:
            logger.error(f"‚ùå Ëé∑ÂèñÂ∑•ÂÖ∑‰ø°ÊÅØÂ§±Ë¥•: {tool_name} | {e}")
            return None

    async def call_tool(
        self, tool_name: str, arguments: Dict[str, Any]
    ) -> McpToolResult:
        """Ë∞ÉÁî®Â∑•ÂÖ∑"""
        import time

        start_time = time.time()

        try:
            if not self.session:
                raise RuntimeError("MCP ÂÆ¢Êà∑Á´ØÊú™ËøûÊé•")

            # Ë∞ÉÁî®Ê†áÂáÜ MCP ÂçèËÆÆ
            response = await self.session.call_tool(tool_name, arguments)

            execution_time = time.time() - start_time

            # ÊèêÂèñÁªìÊûúÂÜÖÂÆπ
            result_content = []
            for content in response.content:
                if content.type == "text":
                    result_content.append(content.text)
                else:
                    result_content.append(str(content))

            result = "\n".join(result_content) if result_content else "Â∑•ÂÖ∑ÊâßË°åÂÆåÊàê"

            logger.info(f"üîß Â∑•ÂÖ∑Ë∞ÉÁî®ÊàêÂäü: {tool_name} -> {result[:100]}...")

            return McpToolResult(
                success=True, result=result, execution_time=execution_time
            )

        except Exception as e:
            execution_time = time.time() - start_time
            error_msg = str(e)

            logger.error(f"‚ùå Â∑•ÂÖ∑Ë∞ÉÁî®Â§±Ë¥•: {tool_name} | {error_msg}")

            return McpToolResult(
                success=False,
                result=None,
                error=error_msg,
                execution_time=execution_time,
            )

    async def call_tool_simple(self, tool_name: str, **kwargs: Any) -> Any:
        """ÁÆÄÂåñÁöÑÂ∑•ÂÖ∑Ë∞ÉÁî®ÊñπÊ≥ïÔºåÁõ¥Êé•ËøîÂõûÁªìÊûú"""
        result = await self.call_tool(tool_name, kwargs)
        if result.success:
            return result.result
        else:
            raise Exception(result.error or "Â∑•ÂÖ∑Ë∞ÉÁî®Â§±Ë¥•")

    async def list_resources(self) -> List[str]:
        """ÂàóÂá∫ÂèØÁî®ËµÑÊ∫ê"""
        try:
            if not self.session:
                raise RuntimeError("MCP ÂÆ¢Êà∑Á´ØÊú™ËøûÊé•")

            response = await self.session.list_resources()
            return [str(resource.uri) for resource in response.resources]

        except Exception as e:
            logger.error(f"‚ùå Ëé∑ÂèñËµÑÊ∫êÂàóË°®Â§±Ë¥•: {e}")
            return []

    async def read_resource(self, uri: str) -> Optional[str]:
        """ËØªÂèñËµÑÊ∫êÂÜÖÂÆπ"""
        try:
            if not self.session:
                raise RuntimeError("MCP ÂÆ¢Êà∑Á´ØÊú™ËøûÊé•")

            response = await self.session.read_resource(uri)  # type: ignore[arg-type]

            # ÊèêÂèñËµÑÊ∫êÂÜÖÂÆπ
            contents = []
            for content in response.contents:
                if hasattr(content, "type") and getattr(content, "type") == "text":
                    contents.append(getattr(content, "text", str(content)))
                else:
                    contents.append(str(content))

            return "\n".join(contents) if contents else None

        except Exception as e:
            logger.error(f"‚ùå ËØªÂèñËµÑÊ∫êÂ§±Ë¥•: {uri} | {e}")
            return None

    async def list_prompts(self) -> List[str]:
        """ÂàóÂá∫ÂèØÁî®ÊèêÁ§∫Ê®°Êùø"""
        try:
            if not self.session:
                raise RuntimeError("MCP ÂÆ¢Êà∑Á´ØÊú™ËøûÊé•")

            response = await self.session.list_prompts()
            return [prompt.name for prompt in response.prompts]

        except Exception as e:
            logger.error(f"‚ùå Ëé∑ÂèñÊèêÁ§∫ÂàóË°®Â§±Ë¥•: {e}")
            return []

    async def get_prompt(
        self, name: str, arguments: Optional[Dict[str, str]] = None
    ) -> Optional[str]:
        """Ëé∑ÂèñÊèêÁ§∫Ê®°ÊùøÂÜÖÂÆπ"""
        try:
            if not self.session:
                raise RuntimeError("MCP ÂÆ¢Êà∑Á´ØÊú™ËøûÊé•")

            response = await self.session.get_prompt(name, arguments or {})

            # ÊèêÂèñÊèêÁ§∫ÂÜÖÂÆπ
            messages = []
            for message in response.messages:
                if hasattr(message, "content") and hasattr(message.content, "text"):
                    messages.append(message.content.text)

            return "\n".join(messages) if messages else None

        except Exception as e:
            logger.error(f"‚ùå Ëé∑ÂèñÊèêÁ§∫Ê®°ÊùøÂ§±Ë¥•: {name} | {e}")
            return None

    def format_tools_for_prompt(self, tools: Optional[List[McpToolInfo]] = None) -> str:
        """Ê†ºÂºèÂåñÂ∑•ÂÖ∑‰ø°ÊÅØÁî®‰∫éÊèêÁ§∫ËØç"""
        if tools is None:
            return "Ëé∑ÂèñÂ∑•ÂÖ∑ÂàóË°®Â§±Ë¥•"

        if not tools:
            return "ÂΩìÂâçÊ≤°ÊúâÂèØÁî®Â∑•ÂÖ∑"

        tool_descriptions = []
        for tool in tools:
            params_desc = ""

            if tool.input_schema and "properties" in tool.input_schema:
                param_list = []
                properties = tool.input_schema["properties"]
                required = tool.input_schema.get("required", [])

                for param_name, param_info in properties.items():
                    param_desc = param_info.get("description", "Êó†ÊèèËø∞")
                    is_required = " (ÂøÖÈúÄ)" if param_name in required else " (ÂèØÈÄâ)"
                    param_list.append(f"{param_name}: {param_desc}{is_required}")

                params_desc = f" ÂèÇÊï∞: {', '.join(param_list)}" if param_list else ""

            tool_desc = f"- {tool.name}: {tool.description}{params_desc}"
            tool_descriptions.append(tool_desc)

        return "\n".join(tool_descriptions)


# ============================================================================
# Â∑•ÂéÇÂáΩÊï∞Ôºà‰øùÁïô‰ª•‰æøÊâ©Â±ïÔºâ
# ============================================================================


def create_stdio_mcp_client(
    command: str, args: Optional[List[str]] = None, env: Optional[Dict[str, str]] = None
) -> McpClient:
    """ÂàõÂª∫ stdio Ê®°ÂºèÁöÑ MCP ÂÆ¢Êà∑Á´Ø"""
    config: Dict[str, Any] = {
        "transport": "stdio",
        "command": command,
    }
    if args:
        config["args"] = args
    if env:
        config["env"] = env
    return McpClient(server_config=config)


def create_streamable_http_mcp_client(url: str) -> McpClient:
    """ÂàõÂª∫ streamable-http Ê®°ÂºèÁöÑ MCP ÂÆ¢Êà∑Á´Ø"""
    config = {"transport": "streamable-http", "url": url}
    return McpClient(server_config=config)
